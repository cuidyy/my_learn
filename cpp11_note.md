# c++11特性

# 稳定性和兼容性

## 1、原始字符串字面量

在C++11中添加了定义原始字符串的字面量，定义方式为：R “xxx(原始字符串)xxx”其中（）两边的字符串可以省略。原始字面量R可以直接表示字符串的实际含义，而不需要额外对字符串做转义或连接等操作。

## 2、类成员的快速初始化

### 初始化类的非静态成员
在定义类的时候在类内部直接对非静态成员变量进行初始化  
初始化的时候可以使用等号 = 也可以使用花括号 {}   

    <code>  
        class Test
        {
        private:
            int a = 9;
            int b = {5};
            int c{12};
            double array[4] = { 3.14, 3.15, 3.16, 3.17};
            double array1[4] { 3.14, 3.15, 3.16, 3.17 };
            string s1("hello");     // error 应该使用{}
            string s2{ "hello, world" };
        };
    </code>

### 初始化列表

## 3、final和override
C++中增加了final关键字来限制某个类不能被继承，或者某个虚函数不能被重写，和Java的final关键字的功能是类似的。如果使用final修饰函数，只能修饰虚函数，并且要把final关键字放到类或者函数的后面  
override关键字确保在派生类中声明的重写函数与基类的虚函数有相同的签名，同时也明确表明将会重写基类的虚函数，这样就可以保证重写的虚函数的正确性，也提高了代码的可读性，和final一样这个关键字要写到方法的后面

## 4、数值类型和字符串之间的转换
to_string()方法可以非常方便地将各种数值类型转换为字符串类型，函数声明位于头文件<string>中  
C++中的数值类型包括整形和浮点型，因此针对于不同的类型提供了不同的函数，通过调用这些函数可以将字符串类型转换为对应的数值类型。stoi()、stol()、stoul()、stoll()、stoull()、stof()、stod()、stold()

## 5、noexcept
表示其修饰的函数不会抛出异常  
noexcept 修饰符有两种形式：  
1. 简单地在函数声明后加上 noexcept 关键字
2. 可以接受一个常量表达式作为参数 noexcept(常量表达式)
    - 值为 true，表示函数不会抛出异常
    - 值为 false，表示函数可能抛出异常
    - 不带常量表达式的noexcept相当于声明了noexcept（true），即不会抛出异常

# 易学和易用性

## 自动类型推导 auto
C++11中auto并不代表一种实际的数据类型，只是一个类型声明的 “占位符”，auto并不是万能的在任意场景下都能够推导出变量的实际类型，使用auto声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在编译时将auto占位符替换为真正的类型。  
不仅如此，auto还可以和指针、引用结合起来使用也可以带上const、volatile限定符，在不同的场景下有对应的推导规则，规则内容如下：

- 当变量不是指针或者引用类型时，推导的结果中不会保留const、volatile关键字
- 当变量是指针或者引用类型时，推导的结果中会保留const、volatile关键字  


        <code>
        int temp = 110;
        auto *a = &temp;	
        auto b = &temp;		
        auto &c = temp;		
        auto d = temp;	
        </code>

- 变量a的数据类型为 int*，因此auto关键字被推导为 int类型
- 变量b的数据类型为 int*，因此auto关键字被推导为 int*类型
- 变量c的数据类型为 int&，因此auto关键字被推导为 int类型
- 变量d的数据类型为 int，因此auto关键字被推导为 int类型

        <code>
        int tmp = 250;
        const auto a1 = tmp;
        auto a2 = a1;
        const auto &a3 = tmp;
        auto &a4 = a3;
        </code>

- 变量a1的数据类型为 const int，因此auto关键字被推导为 int类型
- 变量a2的数据类型为 int，但是a2没有声明为指针或引用因此 const属性被去掉, auto被推导为 int
- 变量a3的数据类型为 const int&，a3被声明为引用因此 const属性被保留，auto关键字被推导为 int类型
- 变量a4的数据类型为 const int&，a4被声明为引用因此 const属性被保留，auto关键字被推导为 const int类型

auto的限制:  
不能作为函数参数使用。因为只有在函数调用的时候才会给函数参数传递实参，auto要求必须要给修饰的变量赋值，因此二者矛盾。
不能用于类的非静态成员变量的初始化  
不能使用auto关键字定义数组  
无法使用auto推导出模板参数

## decltype 类型推导
decltype (表达式)  
表达式为普通变量或者普通表达式或者类表达式，在这种情况下，使用decltype推导出的类型和表达式的类型是一致的。
表达式是函数调用，使用decltype推导出的类型和函数返回值一致  
表达式是一个左值，或者被括号( )包围，使用 decltype推导出的是表达式类型的引用（如果有const、volatile限定符不能忽略）


## 返回类型后置
auto func(T a, T b) -> decltype(a+b)

## 基于范围的for循环
在基于范围的for循环中，不需要再传递容器的两端，循环会自动以容器为范围展开，并且循环中也屏蔽掉了迭代器的遍历细节，直接抽取容器中的元素进行运算，使用这种方式进行循环遍历会让编码和维护变得更加简便。  
for (declaration : expression)  
declaration表示遍历声明，在遍历过程中，当前被遍历到的元素会被存储到声明的变量中。expression是要遍历的对象，它可以是表达式、容器、数组、初始化列表等  
如果需要在遍历过程中修改元素的值，需要使用引用。

## 指针空值类型 - nullptr
nullptr 专用于初始化空类型指针，不同类型的指针变量都可以使用 nullptr 来初始化

## Lambda表达式
### 基本用法
``[capture](params) opt -> ret {body;}``  
capture是捕获列表，params是参数列表，opt是函数选项，ret是返回值类型，body是函数体。  
1. 捕获列表[]: 捕获一定范围内的变量
2. 参数列表(): 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写。
3. opt 选项， 不需要可以省略
    - mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）
    - exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用throw();
4. 返回值类型：在C++11中，lambda表达式的返回值是通过返回值后置语法来定义的。
5. 函数体：函数的实现，这部分不能省略，但函数体可以为空。

### 捕获列表
lambda表达式的捕获列表可以捕获一定范围内的变量，具体使用方式如下：

- [] - 不捕捉任何变量  
- [&] - 捕获外部作用域中所有变量, 并作为引用在函数体内使用 (按引用捕获)  
- [=] - 捕获外部作用域中所有变量, 并作为副本在函数体内使用 (按值捕获)  
    - 拷贝的副本在匿名函数体内部是只读的
- [=, &foo] - 按值捕获外部作用域中所有变量, 并按照引用捕获外部变量 foo
- [bar] - 按值捕获 bar 变量, 同时不捕获其他变量
- [&bar] - 按引用捕获 bar 变量, 同时不捕获其他变量
- [this] - 捕获当前类中的this指针
    - 让lambda表达式拥有和当前类成员函数同样的访问权限
    - 如果已经使用了 & 或者 =, 默认添加此选项

### 返回值
C++11中允许省略lambda表达式的返回值。  
一般情况下，不指定lambda表达式的返回值，编译器会根据return语句自动推导返回值的类型，但需要注意的是labmda表达式不能通过列表初始化自动推导出返回值类型。

### 函数本质
使用lambda表达式捕获列表捕获外部变量，如果希望去修改按值捕获的外部变量，那么应该如何处理呢？这就需要使用mutable选项，被mutable修改是lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性。

为什么通过值拷贝的方式捕获的外部变量是只读的？  
1. lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。
2. 按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。


lambda表达式在C++中会被看做是一个仿函数，因此可以使用std::function和std::bind来存储和操作lambda表达式

对于没有捕获任何变量的lambda表达式，还可以转换成一个普通的函数指针

# 通用性能的提升
## constexpr
用来修饰常量表达式  
凡是表达“只读”语义的场景都使用 const，表达“常量”语义的场景都使用 constexpr。  
在定义常量时，const 和 constexpr 是等价的，都可以在程序的编译阶段计算出结果  
对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的

为了提高C++程序的执行效率，我们可以将程序中值不需要发生变化的变量定义为常量，也可以使用constexpr修饰函数的返回值，这种函数被称作常量表达式函数

constexpr并不能修改任意函数的返回值，使这些函数成为常量表达式函数，必须要满足以下几个条件：  
1. 函数必须要有返回值，并且return 返回的表达式必须是常量表达式。
2. 函数在使用之前，必须有对应的定义语句。
3. 整个函数的函数体中，不能出现非常量表达式之外的语句（using 指令、typedef 语句以及 static_assert 断言、return语句除外）。

## 委托构造函数和继承构造函数
委托构造函数允许使用同一个类中的一个构造函数调用其它的构造函数，从而简化相关变量的初始化。

C++11中提供的继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写

通过使用``using 类名::构造函数名``（其实类名和构造函数名是一样的）来声明使用基类的构造函数，这样子类中就可以不定义相同的构造函数了，直接使用基类的构造函数来构造派生类对象。

另外如果在子类中隐藏了父类中的同名函数，也可以通过using的方式在子类中使用基类中的这些父类函数

## 右值引用
C++11 增加了一个新的类型，称为右值引用（ R-value reference），标记为 &&

### 右值
- lvalue 是loactor value的缩写，rvalue 是 read value的缩写
- 左值是指存储在内存中、有明确存储地址（可取地址）的数据；
- 右值是指可以提供数据值的数据（不可取地址）；

所有有名字的变量或对象都是左值，而右值是匿名的。  
一般情况下，位于=前的表达式为左值，位于=后边的表达式为右值。a=b是一种特殊情况，在这个表达式中a, b都是左值，因为变量b是可以被取地址的，不能视为右值

C++11 中右值可以分为两种：一个是将亡值（ xvalue, expiring value），另一个则是纯右值（ prvalue, PureRvalue）：

- 纯右值：非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和 lambda 表达式等
- 将亡值：与右值引用相关的表达式，比如，T&&类型函数的返回值、 std::move 的返回值等。

### 右值引用
右值引用就是对一个右值进行引用的类型。因为右值是匿名的，所以我们只能通过引用的方式找到它。**无论声明左值引用还是右值引用都必须立即进行初始化，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名。通过右值引用的声明，该右值又“重获新生”**，其生命周期与右值引用类型变量的生命周期一样，只要该变量还活着，该右值临时量将会一直存活下去。

在C++中在进行对象赋值操作的时候，很多情况下会发生对象之间的深拷贝，如果堆内存很大，这个拷贝的代价也就非常大，在某些情况下，如果想要避免对象的深拷贝，就可以使用右值引用进行性能的优化。右值引用具有移动语义，移动语义可以将资源（堆、系统对象等）通过浅拷贝从一个对象转移到另一个对象这样就能减少不必要的临时对象的创建、拷贝以及销毁，可以大幅提高C++应用程序的性能。

在C++中，并不是所有情况下 && 都代表是一个右值引用，具体的场景体现在模板和自动类型推导中，如果是模板参数需要指定为T&&，如果是自动类型推导需要指定为auto &&，在这两种场景下 &&被称作 **未定的引用类型**。  
另外还有一点需要额外注意const T&&表示一个右值引用，不是未定引用类型。

存在T&&或者auto&&这种未定引用类型，当它作为参数时，有可能被一个右值引用初始化，也有可能被一个左值引用初始化，在进行类型推导时右值引用类型（&&）会发生变化，这种变化被称为引用折叠。在C++11中引用折叠的规则如下：

- 通过右值推导 T&& 或者 auto&& 得到的是一个右值引用类型

- 通过非右值（右值引用、左值、左值引用、常量右值引用、常量左值引用）推导 T&& 或者 auto&& 得到的是一个左值引用类型

编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值


## 转移和完美转发

### move
在C++11添加了右值引用，并且不能使用左值初始化右值引用，如果想要使用左值初始化一个右值引用需要借助std::move()函数，使用std::move方法可以将左值转换为右值。使用这个函数并不能移动任何东西，而是和移动构造函数一样都具有移动语义，将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存拷贝

std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);函数原型如下:

    ``
        template<class _Ty>
        _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) _NOEXCEPT
        {	// forward _Arg as movable
            return (static_cast<remove_reference_t<_Ty>&&>(_Arg));
        }
    ``

_Ty&&是一个通用引用类型，它可以接受左值和右值作为参数。当传入一个左值时，_Ty会被推导为左值引用类型；当传入一个右值时，_Ty会被推导为非引用类型。  
static_cast<remove_reference_t<_Ty>&&>首先通过remove_reference_t<_Ty>去除参数_Arg的引用部分，然后再将其转换为右值引用。  

### forward
右值引用类型是独立于值的，一个右值引用作为函数参数的形参时，在函数内部转发该参数给内部其他函数时，它就变成一个左值，并不是原来的类型了。如果需要按照参数原来的类型转发到另一个函数，可以使用C++11提供的std::forward()函数，该函数实现的功能称之为完美转发。

    ``
        // 函数原型
        template <class T> T&& forward (typename remove_reference<T>::type& t) noexcept;
        template <class T> T&& forward (typename remove_reference<T>::type&& t) noexcept;
    ``
- 当T为左值引用类型时，t将被转换为T类型的左值
- 当T不是左值引用类型时，t将被转换为T类型的右值


## 列表初始化

### std::initializer_list

在C++的STL容器中，可以进行任意长度的数据的初始化，使用初始化列表也只能进行固定参数的初始化，如果想要做到和STL一样有任意长度初始化的能力，可以使用std::initializer_list这个轻量级的类模板来实现。


如果想要自定义一个函数并且接收任意个数的参数（变参函数），只需要将函数参数指定为std::initializer_list，使用初始化列表{ }作为实参进行数据传递即可。

自定义的类如果在构造对象的时候想要接收任意个数的实参，可以给构造函数指定为std::initializer_list类型，在自定义类的内部还是使用容器来存储接收的多个实参。


## using的使用
在C++中using用于声明命名空间，使用命名空间也可以防止命名冲突。在程序中声明了命名空间之后，就可以直接使用命名空间中的定义的类了。在C++11中赋予了using新的功能，让C++变得更年轻，更灵活。

### 定义别名
``using 新的类型 = 旧的类型;``

### 模板的别名
C++11中，新增了一个特性就是可以通过使用using来为一个模板定义别名

    ``
    template <typename T>
    using mymap = map<int, T>;
    ``

## 可调用对象包装器、绑定器

### 可调用对象
可调用对象有如下几种定义：  
1. 函数指针
2. 具有operator()成员函数的类对象（仿函数）
3. 可被转换为函数指针的类对象
4. 一个类成员函数指针或者类成员指针

C++11通过提供std::function 和 std::bind统一了可调用对象的各种操作。

### 可调用对象包装器
std::function是可调用对象的包装器。它是一个类模板，可以容纳除了类(非静态)成员（函数）指针之外的所有可调用对象。通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们。

#### 1.基本用法
std::function必须要包含一个叫做functional的头文件，可调用对象包装器使用语法如下:

    ``
    #include <functional>
    std::function<返回值类型(参数类型列表)> diy_name = 可调用对象;
    ``
std::function可以将可调用对象进行包装，得到一个统一的格式，包装完成得到的对象相当于一个函数指针，和函数指针的使用方式相同，通过包装器对象就可以完成对包装的函数的调用了。

#### 2.作为回调函数使用

### 绑定器
std::bind用来将可调用对象与其参数一起进行绑定。绑定后的结果可以使用std::function进行保存，并延迟调用到任何我们需要的时候。通俗来讲，它主要有两大作用：

- 将可调用对象与其参数一起绑定成一个仿函数。
- 将多元（参数个数为n，n>1）可调用对象转换为一元或者（n-1）元可调用对象，即只绑定部分参数。

绑定器函数使用语法格式如下：

    ``
    // 绑定非类成员函数/变量
    auto f = std::bind(可调用对象地址, 绑定的参数/占位符);
    // 绑定类成员函/变量
    auto f = std::bind(类函数/成员地址, 类实例对象地址, 绑定的参数/占位符);
    ``

std::bind绑定器返回的是一个仿函数类型，得到的返回值可以直接赋值给一个std::function，在使用的时候我们并不需要关心绑定器的返回值类型，使用auto进行自动类型推导就可以了。

std::bind可以直接绑定函数的所有参数，也可以仅绑定部分参数。在绑定部分参数的时候，通过使用std::placeholders来决定空位参数将会属于调用发生时的第几个参数。

可调用对象包装器std::function是不能实现对类成员函数指针或者类成员指针的包装的，但是通过绑定器std::bind的配合之后，就可以完美的解决这个问题了

## POD类型
POD是英文中 Plain Old Data 的缩写，翻译过来就是普通的旧数据 。POD在C++中是非常重要的一个概念，通常用于说明一个类型的属性，尤其是用户自定义类型的属性。

- Plain ：表示是个普通的类型
- Old ：体现了其与C的兼容性，支持标准C函数

在C++11中将 POD划分为两个基本概念的合集，即∶平凡的（trivial） 和标准布局的（standard layout ） 

### “平凡”类型
一个平凡的类或者结构体应该符合以下几点要求：
1. 拥有平凡的默认构造函数（trivial constructor）和析构函数（trivial destructor）。（什么都不干）
    - 通常情况下，不定义类的构造函数，编译器就会为我们生成一个平凡的默认构造函数。
    - 一旦定义了构造函数，即使构造函数不包含参数，函数体里也没有任何的代码，那么该构造函数也不再是"平凡"的。

    使用=default关键字可以显式地声明默认的构造函数，从而使得类型恢复 “平凡化”。

2. 拥有平凡的拷贝构造函数（trivial copy constructor）和移动构造函数（trivial move constructor）。

3. 拥有平凡的拷贝赋值运算符（trivial assignment operator）和移动赋值运算符（trivial move operator）。

4. 不包含虚函数以及虚基类。

### “标准布局”类型
标准布局类型主要主要指的是类或者结构体的结构或者组合方式。

标准布局类型的类应该符合以下五点定义，最重要的为前两条：
1. 所有非静态成员有相同 的访问权限（public，private，protected）。

2. 在类或者结构体继承时，满足以下两种情况之一∶
    - 派生类中有非静态成员，基类中包含静态成员（或基类没有变量）。
    - 基类有非静态成员，而派生类没有非静态成员。

3. 子类中第一个非静态成员的类型与其基类不同。
4. 没有虚函数和虚基类

### 对 POD 类型的判断

#### 对“平凡”类型判断
``template <class T> struct std::is_trivial;``

std::is_trivial 的成员value 可以用于判断T的类型是否是一个平凡的类型（value 函数返回值为布尔类型）。除了类和结构体外，is_trivial还可以对内置的标准类型数据（比如int、float都属于平凡类型）及数组类型（元素是平凡类型的数组总是平凡的）进行判断。

#### 对“标准布局”类型的判断
``template <typename T> struct std::is_standard_layout;``  

通过 is_standard_layout模板类的成员 value（is_standard_layout<T>∶∶value），我们可以在代码中打印出类型的标准布局属性，函数返回值为布尔类型。


## 默认函数控制 =default 与 =delete
在C++11标准中称= default修饰的函数为显式默认【缺省】（explicit defaulted）函数，而称=delete修饰的函数为删除（deleted）函数或者显示删除函数。


## placement new
一般情况下，使用new申请空间时，是从系统的堆（heap）中分配空间，申请所得的空间的位置是根据当时的内存的实际使用情况决定的。但是，在某些特殊情况下，可能需要在已分配的特定内存创建对象，这种操作就叫做placement new即定位放置 new。

使用new申请内存空间：Base* ptr = new Base;

使用定位放置new申请内存空间：

``ClassName* ptr = new (定位的内存地址)ClassName;``

1. 使用定位放置new操作，既可以在栈(stack)上生成对象，也可以在堆（heap）上生成对象，这取决于定位时指定的内存地址是在堆还是在栈上。
2. 从表面上看，定位放置new操作是申请空间，其本质是利用已经申请好的空间，真正的申请空间的工作是在此之前完成的。
3. 使用定位放置new操作，我们可以反复动态申请到同一块堆内存，这样可以避免内存的重复创建销毁，从而提高程序的执行效率（比如网络通信中数据的接收和发送）。


# 安全性

## 共享智能指针
智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。

C++11中提供了三种智能指针，使用这些智能指针时需要引用头文件<memory>：

- std::shared_ptr：共享的智能指针
- std::unique_ptr：独占的智能指针
- std::weak_ptr：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视shared_ptr的。



### 1.shared_ptr的初始化
共享智能指针是指多个智能指针可以同时管理同一块有效的内存，共享智能指针shared_ptr 是一个模板类，如果要进行初始化有三种方式：通过构造函数、std::make_shared辅助函数以及reset方法。共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存，如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数use_count，函数原型如下：

    ``  
    // 管理当前对象的 shared_ptr 实例数量，或若无被管理对象则为 0。
    long use_count() const noexcept;  
    ``

#### 1.1 通过构造函数初始化

    ``
    // shared_ptr<T> 类模板中，提供了多种实用的构造函数, 语法格式如下:
    std::shared_ptr<T> 智能指针名字(创建堆内存);
    ``

如果智能指针被初始化了一块有效内存，那么这块内存的引用计数+1，如果智能指针没有被初始化或者被初始化为nullptr空指针，引用计数不会+1。另外，不要使用一个原始指针初始化多个shared_ptr。

#### 1.2 通过拷贝和移动构造函数初始化
当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象。在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就被自动调用了。

#### 1.3 通过std::make_shared初始化
通过C++提供的std::make_shared() 就可以完成内存对象的创建并将其初始化给智能指针，函数原型如下：

    ``
    template< class T, class... Args >
    shared_ptr<T> make_shared( Args&&... args );
    ``

- T：模板参数的数据类型
- Args&&... args ：要初始化的数据，如果是通过make_shared创建对象，需按照构造函数的参数列表指定

使用std::make_shared()模板函数可以完成内存地址的创建，并将最终得到的内存地址传递给共享智能指针对象管理。如果申请的内存是普通类型，通过函数的（）可完成地址的初始化，如果要创建一个类对象，函数的（）内部需要指定构造对象需要的参数，也就是类构造函数的参数。

#### 1.4 通过 reset方法初始化
    ``
    template< class Y, class Deleter, class Alloc >
    void reset( Y* ptr, Deleter d, Alloc alloc );
    ``

- ptr：指向要取得所有权的对象的指针
- d：指向要取得所有权的对象的指针
- aloc：内部存储所用的分配器

对于一个未初始化的共享智能指针，可以通过reset方法来初始化，当智能指针中有值的时候，调用reset会使引用计数减1

### 2. 指定删除器
当智能指针管理的内存对应的引用计数变为0的时候，这块内存就会被智能指针析构掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，这个删除操作对应的函数被称之为删除器，这个删除器函数本质是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的。

在C++11中使用shared_ptr管理动态数组时，需要指定删除器，因为std::shared_ptr的默认删除器不支持数组对象

在删除数组内存时，除了自己编写删除器，也可以使用C++提供的std::default_delete<T>()函数作为删除器，这个函数内部的删除功能也是通过调用delete来实现的，要释放什么类型的内存就将模板类型T指定为什么类型即可


## 独占的智能指针

### 1. 初始化
std::unique_ptr是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针，可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个unique_ptr赋值给另一个unique_ptr。

unique_ptr独占智能指针类也有一个reset方法，函数原型如下：  

``void reset( pointer ptr = pointer() ) noexcept;``  

使用reset方法可以让unique_ptr解除对原始内存的管理，也可以用来初始化一个独占的智能指针。

如果想要获取独占智能指针管理的原始地址，可以调用get()方法，函数原型如下：  
``pointer get() const noexcept;``

### 2. 删除器
unique_ptr指定删除器和shared_ptr指定删除器是有区别的，unique_ptr指定删除器的时候需要确定删除器的类型，所以不能像shared_ptr那样直接指定删除器

    ``
    unique_ptr<int> ptr1(new int(10), [](int*p) {delete p; });	// error

    int main()
    {
        using func_ptr = void(*)(int*);
        unique_ptr<int, func_ptr> ptr1(new int(10), [](int*p) {delete p; });

        return 0;
    }
    ``

## 弱引用智能指针
弱引用智能指针std::weak_ptr可以看做是shared_ptr的助手，它不管理shared_ptr内部的指针。std::weak_ptr没有重载操作符*和->，因为它不共享指针，不能操作资源，所以它的构造不会增加引用计数，析构也不会减少引用计数，它的主要作用就是作为一个旁观者监视shared_ptr中管理的资源是否存在。

### 1.1 初始化
    ``
    // 默认构造函数
    constexpr weak_ptr() noexcept;
    // 拷贝构造
    weak_ptr (const weak_ptr& x) noexcept;
    template <class U> weak_ptr (const weak_ptr<U>& x) noexcept;
    // 通过shared_ptr对象构造
    template <class U> weak_ptr (const shared_ptr<U>& x) noexcept;
    ``

通过调用std::weak_ptr类提供的use_count()方法可以获得当前所观测资源的引用计数

通过调用std::weak_ptr类提供的expired()方法来判断观测的资源是否已经被释放

通过调用std::weak_ptr类提供的lock()方法来获取管理所监测资源的shared_ptr对象  
``shared_ptr<element_type> lock() const noexcept;``

通过调用std::weak_ptr类提供的reset()方法来清空对象，使其不监测任何资源

shared_from_this()  
这个函数主要用于在一个已经被std::shared_ptr管理的对象中，获取一个指向自身的std::shared_ptr

# 多线程
## C++线程类 thread
C++11中提供的线程类叫做std::thread，基于这个类创建一个新的线程非常的简单，只需要提供线程函数或者函数对象即可，并且可以同时指定线程函数的参数。

### 1. 构造函数

    ``
    // 1
    thread() noexcept;
    // 2
    thread( thread&& other ) noexcept;
    // 3
    template< class Function, class... Args >
    explicit thread( Function&& f, Args&&... args );
    // 4
    thread( const thread& ) = delete;
    ``
构造函数1：默认构造函，构造一个线程对象，在这个线程中不执行任何处理动作

构造函数2：移动构造函数，将 other 的线程所有权转移给新的thread 对象。之后 other 不再表示执行线程。

构造函数3：创建线程对象，并在该线程中执行函数f中的业务逻辑，args是要传递给函数f的参数

- 任务函数f的可选类型有很多，具体如下：

    - 普通函数，类成员函数，匿名函数，仿函数（这些都是可调用对象类型）
    - 可以是可调用对象包装器类型，也可以是使用绑定器绑定之后得到的类型（仿函数）

构造函数4：使用=delete显示删除拷贝构造, 不允许线程对象之间的拷贝

### 2. 公共成员函数
get_id(): 获取线程ID

join(): 字面意思是连接一个线程，意味着主动地等待线程的终止（线程阻塞）。在某个线程中通过子线程对象调用join()函数，调用这个函数的线程被阻塞，但是子线程对象中的任务函数会继续执行，当任务执行完毕之后join()会清理当前子线程中的相关资源然后返回，同时，调用该函数的线程解除阻塞继续向下执行。(函数在哪个线程中被执行，那么函数就阻塞哪个线程。)

detach(): 函数的作用是进行线程分离，分离主线程和创建出的子线程。在线程分离之后，主线程退出也会一并销毁创建出的所有子线程，在主线程退出之前，它可以脱离主线程继续独立的运行，任务执行完毕之后，这个子线程会自动释放自己占用的系统资源。(注意事项：线程分离函数detach()不会阻塞线程，子线程和主线程分离之后，在主线程中就不能再对这个子线程做任何控制了，)

joinable(): 函数用于判断主线程和子线程是否处理关联（连接）状态，一般情况下，二者之间的关系处于关联状态，该函数返回一个布尔类型：

线程中的资源是不能被复制的，因此通过=操作符进行赋值操作最终并不会得到两个完全相同的对象。
- 如果other是一个右值，会进行资源所有权的转移
- 如果other不是右值，禁止拷贝，该函数被显示删除（=delete），不可用

## 命名空间 - this_thread
在C++11中不仅添加了线程类，还添加了一个关于线程的命名空间std::this_thread，在这个命名空间中提供了四个公共的成员函数

调用命名空间std::this_thread中的get_id()方法可以得到当前线程的线程ID

休眠函数sleep_for()，调用这个函数的线程会马上从运行态变成阻塞态

yield()，在线程中调用这个函数之后，处于运行态的线程会主动让出自己已经抢到的CPU时间片，最终变为就绪态，这样其它的线程就有更大的概率能够抢到CPU时间片了。

## C++线程同步之互斥锁

### std::mutex

#### 成员函数
lock()函数用于给临界区加锁，并且只能有一个线程获得锁的所有权，它有阻塞线程的作用

``void lock();``

独占互斥锁对象有两种状态：锁定和未锁定。如果互斥锁是打开的，调用lock()函数的线程会得到互斥锁的所有权，并将其上锁，其它线程再调用该函数的时候由于得不到互斥锁的所有权，就会被lock()函数阻塞。当拥有互斥锁所有权的线程将互斥锁解锁，此时被lock()阻塞的线程解除阻塞，抢到互斥锁所有权的线程加锁并继续运行，没抢到互斥锁所有权的线程继续阻塞。

除了使用lock()还可以使用try_lock()获取互斥锁的所有权并对互斥锁加锁，函数原型如下：

``bool try_lock();``  
二者的区别在于try_lock()不会阻塞线程，lock()会阻塞线程

当互斥锁被锁定之后可以通过unlock()进行解锁，但是需要注意的是只有拥有互斥锁所有权的线程也就是对互斥锁上锁的线程才能将其解锁，其它线程是没有权限做这件事情的。

``void unlock();``

互斥锁的个数和共享资源的个数相等，也就是说每一个共享资源都应该对应一个互斥锁对象。互斥锁对象的个数和线程的个数没有关系。

## C++线程同步之条件变量
### condition_variable
C++11提供了两种条件变量
- condition_variable：需要配合std::unique_lock<std::mutex>进行wait操作，也就是阻塞线程的操作。
- condition_variable_any：可以和任意带有lock()、unlock()语义的mutex搭配使用

#### 成员函数
condition_variable的成员函数主要分为两部分：线程等待（阻塞）函数 和线程通知（唤醒）函数，这些函数被定义于头文件 <condition_variable>。

    ``
    // 1
    void wait (unique_lock<mutex>& lck);
    // 2
    template <class Predicate>
    void wait (unique_lock<mutex>& lck, Predicate pred);
    ``

- 函数1：调用该函数的线程直接被阻塞

- 函数2：该函数的第二个参数是一个判断条件，是一个返回值为布尔类型的函数

    - 该参数可以传递一个有名函数的地址，也可以直接指定一个匿名函数
    - 表达式返回false当前线程被阻塞，表达式返回true当前线程不会被阻塞，继续向下执行

独占的互斥锁对象不能直接传递给wait()函数，需要通过模板类unique_lock进行二次处理，通过得到的对象仍然可以对独占的互斥锁对象做如下操作，使用起来更灵活。

如果线程被该函数阻塞，这个线程会释放占有的互斥锁的所有权，当阻塞解除之后这个线程会重新得到互斥锁的所有权，继续向下执行（这个过程是在函数内部完成的，了解这个过程即可，其目的是为了避免线程的死锁）。

- notify_one()：唤醒一个被当前条件变量阻塞的线程
- notify_all()：唤醒全部被当前条件变量阻塞的线程



