# c++11特性

# 稳定性和兼容性

## 1、原始字符串字面量

在C++11中添加了定义原始字符串的字面量，定义方式为：R “xxx(原始字符串)xxx”其中（）两边的字符串可以省略。原始字面量R可以直接表示字符串的实际含义，而不需要额外对字符串做转义或连接等操作。

## 2、类成员的快速初始化

### 初始化类的非静态成员
在定义类的时候在类内部直接对非静态成员变量进行初始化  
初始化的时候可以使用等号 = 也可以使用花括号 {}   

    <code>  
        class Test
        {
        private:
            int a = 9;
            int b = {5};
            int c{12};
            double array[4] = { 3.14, 3.15, 3.16, 3.17};
            double array1[4] { 3.14, 3.15, 3.16, 3.17 };
            string s1("hello");     // error 应该使用{}
            string s2{ "hello, world" };
        };
    </code>

### 初始化列表

## 3、final和override
C++中增加了final关键字来限制某个类不能被继承，或者某个虚函数不能被重写，和Java的final关键字的功能是类似的。如果使用final修饰函数，只能修饰虚函数，并且要把final关键字放到类或者函数的后面  
override关键字确保在派生类中声明的重写函数与基类的虚函数有相同的签名，同时也明确表明将会重写基类的虚函数，这样就可以保证重写的虚函数的正确性，也提高了代码的可读性，和final一样这个关键字要写到方法的后面

## 4、数值类型和字符串之间的转换
to_string()方法可以非常方便地将各种数值类型转换为字符串类型，函数声明位于头文件<string>中  
C++中的数值类型包括整形和浮点型，因此针对于不同的类型提供了不同的函数，通过调用这些函数可以将字符串类型转换为对应的数值类型。stoi()、stol()、stoul()、stoll()、stoull()、stof()、stod()、stold()

## 5、noexcept
表示其修饰的函数不会抛出异常  
noexcept 修饰符有两种形式：  
1. 简单地在函数声明后加上 noexcept 关键字
2. 可以接受一个常量表达式作为参数 noexcept(常量表达式)
    - 值为 true，表示函数不会抛出异常
    - 值为 false，表示函数可能抛出异常
    - 不带常量表达式的noexcept相当于声明了noexcept（true），即不会抛出异常

# 易学和易用性

## 自动类型推导 auto
C++11中auto并不代表一种实际的数据类型，只是一个类型声明的 “占位符”，auto并不是万能的在任意场景下都能够推导出变量的实际类型，使用auto声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在编译时将auto占位符替换为真正的类型。  
不仅如此，auto还可以和指针、引用结合起来使用也可以带上const、volatile限定符，在不同的场景下有对应的推导规则，规则内容如下：

- 当变量不是指针或者引用类型时，推导的结果中不会保留const、volatile关键字
- 当变量是指针或者引用类型时，推导的结果中会保留const、volatile关键字  


        <code>
        int temp = 110;
        auto *a = &temp;	
        auto b = &temp;		
        auto &c = temp;		
        auto d = temp;	
        </code>

- 变量a的数据类型为 int*，因此auto关键字被推导为 int类型
- 变量b的数据类型为 int*，因此auto关键字被推导为 int*类型
- 变量c的数据类型为 int&，因此auto关键字被推导为 int类型
- 变量d的数据类型为 int，因此auto关键字被推导为 int类型

        <code>
        int tmp = 250;
        const auto a1 = tmp;
        auto a2 = a1;
        const auto &a3 = tmp;
        auto &a4 = a3;
        </code>

- 变量a1的数据类型为 const int，因此auto关键字被推导为 int类型
- 变量a2的数据类型为 int，但是a2没有声明为指针或引用因此 const属性被去掉, auto被推导为 int
- 变量a3的数据类型为 const int&，a3被声明为引用因此 const属性被保留，auto关键字被推导为 int类型
- 变量a4的数据类型为 const int&，a4被声明为引用因此 const属性被保留，auto关键字被推导为 const int类型

auto的限制:  
不能作为函数参数使用。因为只有在函数调用的时候才会给函数参数传递实参，auto要求必须要给修饰的变量赋值，因此二者矛盾。
不能用于类的非静态成员变量的初始化  
不能使用auto关键字定义数组  
无法使用auto推导出模板参数

## decltype 类型推导
decltype (表达式)  
表达式为普通变量或者普通表达式或者类表达式，在这种情况下，使用decltype推导出的类型和表达式的类型是一致的。
表达式是函数调用，使用decltype推导出的类型和函数返回值一致  
表达式是一个左值，或者被括号( )包围，使用 decltype推导出的是表达式类型的引用（如果有const、volatile限定符不能忽略）


## 返回类型后置
auto func(T a, T b) -> decltype(a+b)

## 基于范围的for循环
在基于范围的for循环中，不需要再传递容器的两端，循环会自动以容器为范围展开，并且循环中也屏蔽掉了迭代器的遍历细节，直接抽取容器中的元素进行运算，使用这种方式进行循环遍历会让编码和维护变得更加简便。  
for (declaration : expression)  
declaration表示遍历声明，在遍历过程中，当前被遍历到的元素会被存储到声明的变量中。expression是要遍历的对象，它可以是表达式、容器、数组、初始化列表等  
如果需要在遍历过程中修改元素的值，需要使用引用。

## 指针空值类型 - nullptr
nullptr 专用于初始化空类型指针，不同类型的指针变量都可以使用 nullptr 来初始化

## Lambda表达式
### 基本用法
``[capture](params) opt -> ret {body;}``  
capture是捕获列表，params是参数列表，opt是函数选项，ret是返回值类型，body是函数体。  
1. 捕获列表[]: 捕获一定范围内的变量
2. 参数列表(): 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写。
3. opt 选项， 不需要可以省略
    - mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）
    - exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用throw();
4. 返回值类型：在C++11中，lambda表达式的返回值是通过返回值后置语法来定义的。
5. 函数体：函数的实现，这部分不能省略，但函数体可以为空。

### 捕获列表
lambda表达式的捕获列表可以捕获一定范围内的变量，具体使用方式如下：

- [] - 不捕捉任何变量  
- [&] - 捕获外部作用域中所有变量, 并作为引用在函数体内使用 (按引用捕获)  
- [=] - 捕获外部作用域中所有变量, 并作为副本在函数体内使用 (按值捕获)  
    - 拷贝的副本在匿名函数体内部是只读的
- [=, &foo] - 按值捕获外部作用域中所有变量, 并按照引用捕获外部变量 foo
- [bar] - 按值捕获 bar 变量, 同时不捕获其他变量
- [&bar] - 按引用捕获 bar 变量, 同时不捕获其他变量
- [this] - 捕获当前类中的this指针
    - 让lambda表达式拥有和当前类成员函数同样的访问权限
    - 如果已经使用了 & 或者 =, 默认添加此选项

### 返回值
C++11中允许省略lambda表达式的返回值。  
一般情况下，不指定lambda表达式的返回值，编译器会根据return语句自动推导返回值的类型，但需要注意的是labmda表达式不能通过列表初始化自动推导出返回值类型。

### 函数本质
使用lambda表达式捕获列表捕获外部变量，如果希望去修改按值捕获的外部变量，那么应该如何处理呢？这就需要使用mutable选项，被mutable修改是lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性。

为什么通过值拷贝的方式捕获的外部变量是只读的？  
1. lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。
2. 按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。


lambda表达式在C++中会被看做是一个仿函数，因此可以使用std::function和std::bind来存储和操作lambda表达式

对于没有捕获任何变量的lambda表达式，还可以转换成一个普通的函数指针

# 通用性能的提升
## constexpr
用来修饰常量表达式  
凡是表达“只读”语义的场景都使用 const，表达“常量”语义的场景都使用 constexpr。  
在定义常量时，const 和 constexpr 是等价的，都可以在程序的编译阶段计算出结果  
对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的

为了提高C++程序的执行效率，我们可以将程序中值不需要发生变化的变量定义为常量，也可以使用constexpr修饰函数的返回值，这种函数被称作常量表达式函数

constexpr并不能修改任意函数的返回值，使这些函数成为常量表达式函数，必须要满足以下几个条件：  
1. 函数必须要有返回值，并且return 返回的表达式必须是常量表达式。
2. 函数在使用之前，必须有对应的定义语句。
3. 整个函数的函数体中，不能出现非常量表达式之外的语句（using 指令、typedef 语句以及 static_assert 断言、return语句除外）。

## 委托构造函数和继承构造函数
委托构造函数允许使用同一个类中的一个构造函数调用其它的构造函数，从而简化相关变量的初始化。

C++11中提供的继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写

通过使用``using 类名::构造函数名``（其实类名和构造函数名是一样的）来声明使用基类的构造函数，这样子类中就可以不定义相同的构造函数了，直接使用基类的构造函数来构造派生类对象。

另外如果在子类中隐藏了父类中的同名函数，也可以通过using的方式在子类中使用基类中的这些父类函数

## 右值引用
C++11 增加了一个新的类型，称为右值引用（ R-value reference），标记为 &&

### 右值
- lvalue 是loactor value的缩写，rvalue 是 read value的缩写
- 左值是指存储在内存中、有明确存储地址（可取地址）的数据；
- 右值是指可以提供数据值的数据（不可取地址）；

所有有名字的变量或对象都是左值，而右值是匿名的。  
一般情况下，位于=前的表达式为左值，位于=后边的表达式为右值。a=b是一种特殊情况，在这个表达式中a, b都是左值，因为变量b是可以被取地址的，不能视为右值

C++11 中右值可以分为两种：一个是将亡值（ xvalue, expiring value），另一个则是纯右值（ prvalue, PureRvalue）：

- 纯右值：非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和 lambda 表达式等
- 将亡值：与右值引用相关的表达式，比如，T&&类型函数的返回值、 std::move 的返回值等。

### 右值引用
右值引用就是对一个右值进行引用的类型。因为右值是匿名的，所以我们只能通过引用的方式找到它。**无论声明左值引用还是右值引用都必须立即进行初始化，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名。通过右值引用的声明，该右值又“重获新生”**，其生命周期与右值引用类型变量的生命周期一样，只要该变量还活着，该右值临时量将会一直存活下去。

在C++中在进行对象赋值操作的时候，很多情况下会发生对象之间的深拷贝，如果堆内存很大，这个拷贝的代价也就非常大，在某些情况下，如果想要避免对象的深拷贝，就可以使用右值引用进行性能的优化。右值引用具有移动语义，移动语义可以将资源（堆、系统对象等）通过浅拷贝从一个对象转移到另一个对象这样就能减少不必要的临时对象的创建、拷贝以及销毁，可以大幅提高C++应用程序的性能。

在C++中，并不是所有情况下 && 都代表是一个右值引用，具体的场景体现在模板和自动类型推导中，如果是模板参数需要指定为T&&，如果是自动类型推导需要指定为auto &&，在这两种场景下 &&被称作 **未定的引用类型**。  
另外还有一点需要额外注意const T&&表示一个右值引用，不是未定引用类型。

存在T&&或者auto&&这种未定引用类型，当它作为参数时，有可能被一个右值引用初始化，也有可能被一个左值引用初始化，在进行类型推导时右值引用类型（&&）会发生变化，这种变化被称为引用折叠。在C++11中引用折叠的规则如下：

- 通过右值推导 T&& 或者 auto&& 得到的是一个右值引用类型

- 通过非右值（右值引用、左值、左值引用、常量右值引用、常量左值引用）推导 T&& 或者 auto&& 得到的是一个左值引用类型

编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值


## 转移和完美转发
在C++11添加了右值引用，并且不能使用左值初始化右值引用，如果想要使用左值初始化一个右值引用需要借助std::move()函数，使用std::move方法可以将左值转换为右值。使用这个函数并不能移动任何东西，而是和移动构造函数一样都具有移动语义，将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存拷贝

std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);函数原型如下:

    ``
        template<class _Ty>
        _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) _NOEXCEPT
        {	// forward _Arg as movable
            return (static_cast<remove_reference_t<_Ty>&&>(_Arg));
        }
    ``




















